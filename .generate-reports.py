#!/usr/bin/env python

# Script to generate a Maven site and push reports to a branch (gh-pages by default).
# This script assumes that both git and Maven have been installed and that the following environment variables
# are defined:
#   - REPORTS_GITHUB_ACCESS_TOKEN: GitHub personal access token used to push generated reports
#   - REPORTS_GITHUB_USERNAME: username used to push generated reports
# 
# Yes, these could be passed as arguments, but Travis log would print them out.

# Output of this script is to populate the gh-pages branch with the reports generated by running "mvn site".
# The structure of the generated reports is similar to:
# 
# (branch gh-pages)
# .
# ├── development
# │   ├── index.html
# │   ├── pmd.html
# │   ├── jacoco.html
# │   └── ...
# │  
# ├── 1.0.0
# │   ├── index.html
# │   ├── pmd.html
# │   ├── jacoco.html
# │   └── ...
# │  
# ├── 1.0.1
# │   ├── index.html
# │   ├── pmd.html
# │   ├── jacoco.html
# │   └── ...
# │  
# └── 2.0.0
#     ├── index.html
#     ├── pmd.html
#     ├── jacoco.html
#     └── ...
#
# So only one "development" version of the reports is maintained, while reports for all 
# tagged commits--assumed to be releases--are maintained on the gh-pages branch. 
# 
# The content of each of the folders is whatever Maven generates on the target/site folder.


import argparse, os, shutil, subprocess, tempfile

# folder where maven outputs reports generated by running "mvn site"
MAVEN_SITE_DIR = os.path.join('target', 'site')
# base directory where reports will be copied to
BASE_REPORT_DIR = 'reports'
# credentials are given via environment variables
USERNAME_ENV_VARIABLE_NAME = 'REPORTS_GITHUB_USERNAME'
TOKEN_ENV_VARIABLE_NAME = 'REPORTS_GITHUB_ACCESS_TOKEN'
# files that should not be deleted when cleaning the working folder (in gh-pages)
UNTOUCHABLE_FILES = ['.git']


# parses arguments
def main():
    parser = argparse.ArgumentParser(description='QBiC Javadoc Generator.', prog='generate-javadocs.py', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-s', '--site-dir', default=MAVEN_SITE_DIR,
        help='Directory where Maven generates reports after executing "mvn site".')
    parser.add_argument('-b', '--base-output-dir', default=BASE_REPORT_DIR,
        help='Base directory where the reports will be copied.')    
    parser.add_argument('-p', '--pages-branch', default="gh-pages",
        help='Name of the git branch on which the reports will be pushed.')
    parser.add_argument('-u', '--username-var-name', default=USERNAME_ENV_VARIABLE_NAME,
        help='Name of the environment variable holding the GitHub username used to push changes in reports.')
    parser.add_argument('-a', '--access-token-var-name', default=TOKEN_ENV_VARIABLE_NAME,
        help='Name of the environment variable holding the GitHub personal access token used to push changes in reports.')
    parser.add_argument('output_dir', 
        help='Name of the folder, relative to the base output directory, where reports will be copied to. \
              This folder will be first cleared of its contents before the generated reports are copied. \
              Recommended values are: "development" or a valid release version string (e.g., 1.0.1)')
    parser.add_argument('repo_slug', help='Slug of the repository for which reports are being built.')
    parser.add_argument('commit_message', nargs='+', help='Message(s) to use when committing changes.')
    args = parser.parse_args()

    # check that the required environment variables have been defined
    if not args.username_var_name in os.environ or not args.access_token_var_name in os.environ:
        raise Exception('At least one of the required environment variables is missing. See comments on .generate-reports.py for further information.')

    # generate the reports using maven
    print('Generating reports using "mvn site"')
    execute(['mvn', 'site'], 'Could not generate reports')
    # check that the reports are where they should be (you never know!)
    if not os.path.exists(args.site_dir) or not os.path.isdir(args.site_dir):
        raise Exception('Maven site folder {} does not exist or is not a directory.'.format(args.site_dir))

    # since this will run on Travis, we cannot assume that we can change the current local repo without breaking anything
    # the safest way would be to clone this same repository on a temporary folder and leave the current local repo alone
    working_dir = tempfile.mkdtemp()
    print('Cloning {} into temporary folder {}'.format(args.repo_slug, working_dir))
    custom_remote = build_remote(args)
    execute(['git', 'clone', custom_remote, working_dir], 'Could not clone {} in directory {}'.format(args.repo_slug, working_dir))
    
    # change to the pages branch, pull changes 
    # we need to add the gh-pages branch if it doesn't exist (git checkout -b gh-pages),
    # but if gh-pages already exists, we need to checkout (git checkout gh-pages), luckily, 
    # "git checkout -b branch" fails if branch already exists
    print('Changing to branch {}'.format(args.pages_branch))
    try:
        execute(['git', '-C', working_dir, 'checkout', args.pages_branch])
    except:
        execute(['git', '-C', working_dir, 'checkout', '-b', args.pages_branch], 'Could not create branch {}'.format(args.pages_branch))

    # since branches have a parent commit, we have to remove everything but:
    #  * important files (e.g., .git) 
    #  * the base output directory (args.base_output_dir) 
    # otherwise, the gh-pages branch will contain other non-report files!
    print('Cleaning local repository ({}) of non-reports files'.format(working_dir))
    for f in os.listdir(working_dir):
        if should_delete(f, args):
            # instead of using OS calls to delete files/folders, use git rm to stage deletions
            print('    Deleting {} from {} branch'.format(f, args.pages_branch))
            execute(['git', '-C', working_dir, 'rm', '-r', '--ignore-unmatch', f], 'Could not remove {}.'.format(f))
        else:
            print('    Ignoring file/folder {}'.format(f))

    # remove the contents of the output folder before copying the generated reports
    report_output_dir = os.path.join(working_dir, args.base_output_dir, args.output_dir)
    if os.path.exists(report_output_dir):
        if not os.path.isdir(report_output_dir):
            raise Exception('Output destination {} exists and is not a directory.'.format(report_output_dir))
        # output path exists and it's a folder, we can safely delete it
        print('Removing {}'.format(report_output_dir))
        execute(['git', '-C', working_dir, 'rm', '-r', '--ignore-unmatch', os.path.join(args.base_output_dir, args.output_dir)], 
                 'Could not remove {}.'.format(report_output_dir))
    # we know the output folder doesn't exist, so we can recreate it
    print('Creating {}'.format(report_output_dir))
    os.makedirs(report_output_dir)

    # accidentally the whole target/site folder (well, yes, but actually, no, because we need only its contents)
    print('Moving contents of {} to {}'.format(args.site_dir, report_output_dir))
    for f in os.listdir(args.site_dir):
        print('    Moving {}'.format(f))
        shutil.move(os.path.join(args.site_dir, f), report_output_dir)
    
    # TODO: do we really need this if we are cloning the repo with credentials?
    # make sure to add a remote with the credentials provided via environment variables
    print('Configuring remote using provided credentials')
    execute(['git', '-C', working_dir, 'remote', 'rm', 'origin'], 'Could not remove "origin" remote.')
    execute(['git', '-C', working_dir, 'remote', 'add', 'origin', custom_remote], 
             'Could not add "origin" remote with custom credentials')

    # add changes to the index
    print('Staging changes for commit')
    execute(['git', '-C', working_dir, 'add', '.'], 'Could not stage reports for commit.')
    
    # build the git-commit command and commit changes
    print('Pushing changes upstream')
    git_commit_command = ['git', '-C', working_dir, 'commit']
    for commit_message in args.commit_message:
        git_commit_command.extend(['-m', commit_message])
    execute(git_commit_command, 'Could not commit changes')

    # https://www.youtube.com/watch?v=vCadcBR95oU
    execute(['git', '-C', working_dir, 'push', '-u', 'origin', args.pages_branch], 'Could not push changes using provided credentials.')

    # clean up
    print('Removing working folder {}'.format(working_dir))
    shutil.rmtree(working_dir)


# whether it is safe to delete the given path, we won't delete important files/folders (such as .git)
# or the base output directory
def should_delete(path, args):    
    return path not in UNTOUCHABLE_FILES and path != args.base_output_dir


# builds a git remote using environment variables for credentials and the repo slug
def build_remote(args):
    return 'https://{}:{}@github.com/{}'.format(os.environ[args.username_var_name], os.environ[args.access_token_var_name], args.repo_slug)


# executes an external command, raises an exception if the return code is not 0
# stderr/stdout are hidden by default to avoid leaking credentials into log files in Travis
# Important: do not commit code that might print sensitive information, this might end up in a log somewhere outside our control
def execute(command, error_message='Error encountered while executing command', hide_stderr=True, hide_stdout=True):
    # do not print the command! this might expose usernames/passwords/tokens!
    completed_process = subprocess.run(command, capture_output=True)
    if (completed_process.returncode != 0):
        raise Exception('{}\n  Exit code={}\n  stderr={}\n  stdout{}'.format(
            error_message, completed_process.returncode, 
            '***hidden***' if hide_stderr else completed_process.stderr, 
            '***hidden***' if hide_stdout else completed_process.stdout))

if __name__ == "__main__":
    main()
